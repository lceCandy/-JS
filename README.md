# 有趣的JS代码(持续记录)

js 代码记录
### 商品浏览实现效果

![实现效果](https://github.com/lceCandy/-JS/blob/master/%E5%95%86%E5%93%81%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%B0%81%E8%A3%85/%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C.jpg)

### 井字棋胜利判断算法(Tic-Tac-Toe) 

来源于一道前端面试题：

> 假设我们现在有一个 3 x 3 的井字棋游戏，我们用一个二维数组代表棋盘，’x’ 代表玩家 X 下的棋子，’o’ 代表玩家 O 下的棋子，’e’ 代表该格没有棋子。例如：
>
> 一个空白的棋盘以下面的二维数组表示
>
> [ [‘e’, ‘e’, ‘e’],
>
>   [‘e’, ‘e’, ‘e’],
>
>   [‘e’, ‘e’, ‘e’] ]
>
> 如果玩家 X 在第一行第一列下了一步棋，玩家 O 在第二行第二列下了一步棋，则表示如下：
>
> [ [‘x’, ‘e’, ‘e’],
>
>   [‘e’, ‘o’, ‘e’],
>
>   [‘e’, ‘e’, ‘e’] ]
>
> 现在需要一个 function，接受一个已有任意棋子的棋盘（和上面二维数组一样的格式），和玩家的标志（’x’ 或 ‘o'），返回该玩家下一步有几种可能的获胜方式（获胜方式以数组表示，[0, 0] 代表在第一行第一列下一步棋即可获胜，[2, 2] 代表在第三行第三列下一步棋即可获胜）。例如：
>
> someFunction(
>
> ‘x’,
>
> [ [‘o’, ‘e’, ‘e’],
>
>   [‘o’, ‘x’, ‘o’],
>
>   [‘x’, ‘x’, ‘e’] ]
>
> )
>
> // return [ [2, 2], [0, 1], [0, 2] ]
>
> someFunction(
>
> ‘x’,
>
> [ [‘x’, ‘o’, ‘o’],
>
>   [‘x’, ‘x’, ‘e’],
>
>   [‘e’, ‘o’, ‘e’] ]
>
> )
>
> // return [ [2, 2], [1, 2], [2, 0] ]
>
> someFunction(
>
> ‘x’,
>
> [ [‘x’, ‘x’, ‘o’],
>
>   [‘e’, ‘e’, ‘e’],
>
>   [‘e’, ‘e’, ‘e’] ]
>
> )
>
> // return [ ]
>
> someFunction(
>
> ‘o’,
>
> [ [‘o’, ‘o’, ‘o’],
>
>   [‘e’, ‘e’, ‘e’],
>
>   [‘e’, ‘e’, ‘e’] ]
>
> )
>
> // return [ ]
>
> 除了实现功能以外，我们还有一些加分项：
>
> 代码可读性高
>
> 代码量少
>
> 性能高
>
> 有可运行的单元测试
>
> 使用 ES6 语法实现
>
> 使用 functional programming 实现

考虑到井字棋游戏的胜利结果仅仅只有八种结果，所以我认为把胜利条件直接储存在一个三维数组里进行匹配即可；单元测试用到了[Mocha](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)(发音：摩卡)测试结果如下：

![](http://ww1.sinaimg.cn/large/c2d23501gy1fuppdashnqj20hx05ngls.jpg)